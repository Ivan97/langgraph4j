{"mappings":"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","sources":["<anon>","src/lg4j-executor.js","src/lg4j-executor-test.js","node_modules/@parcel/node-resolver-core/lib/_empty.js"],"sourcesContent":["\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire0031\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire0031\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $hNeh9 = parcelRequire(\"hNeh9\");\n\nvar $800sp = parcelRequire(\"800sp\");\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData\n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */ /**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */ const $fe8cbfd9ee8314da$var$delay = async (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\nconst $fe8cbfd9ee8314da$export$749baee93d8a648e = {\n    /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */ callInit: async (elem)=>{\n        /** @typedef {InitData} */ const detail = {\n            threads: [\n                [\n                    'default',\n                    []\n                ]\n            ],\n            title: 'LangGraph4j : TEST',\n            args: [\n                {\n                    name: 'input',\n                    type: 'STRING',\n                    required: true\n                }\n            ],\n            graph: `\n---\ntitle: TEST\n---        \nflowchart TD\n  start((start))\n  stop((stop))\n  web_search(\"web_search\")\n  retrieve(\"retrieve\")\n  grade_documents(\"grade_documents\")\n  generate(\"generate\")\n  transform_query(\"transform_query\")\n  start:::start -->|web_search| web_search:::web_search\n  start:::start -->|vectorstore| retrieve:::retrieve\n  web_search:::web_search --> generate:::generate\n  retrieve:::retrieve --> grade_documents:::grade_documents\n  grade_documents:::grade_documents -->|transform_query| transform_query:::transform_query\n  grade_documents:::grade_documents -->|generate| generate:::generate\n  transform_query:::transform_query --> retrieve:::retrieve\n  generate:::generate -->|not supported| generate:::generate\n  generate:::generate -->|not useful| transform_query:::transform_query\n  generate:::generate -->|useful| stop:::stop\n      `\n        };\n        await $fe8cbfd9ee8314da$var$delay(1000);\n        /** @typedef {CustomEvent<InitData>} */ const event = new CustomEvent('init', {\n            detail: detail,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        });\n        elem.dispatchEvent(event);\n        // @ts-ignore\n        return detail;\n    },\n    /**\n   * @param   {HTMLElement}  elem\n   * @param   {string|undefined}  selectedThread \n   */ callSubmitAction: async (elem, selectedThread)=>{\n        const thread = selectedThread;\n        const send = async (/** @type {string} */ nodeId, /** @type {string} */ nextNodeId)=>{\n            /** @typedef {ResultData} */ const detail = [\n                thread,\n                {\n                    checkpoint: nodeId === 'start' || nodeId === 'stop' ? undefined : `checkpoint-${nodeId}`,\n                    node: nodeId,\n                    next: nextNodeId,\n                    state: {\n                        input: \"this is input\",\n                        property1: {\n                            value: \"value1\",\n                            valid: true\n                        },\n                        property2: {\n                            value: \"value2\",\n                            children: {\n                                elements: [\n                                    1,\n                                    2,\n                                    3\n                                ]\n                            }\n                        }\n                    }\n                }\n            ];\n            /** @typedef {CustomEvent<ResultData>} */ const event = new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            });\n            await $fe8cbfd9ee8314da$var$delay(1000);\n            elem.dispatchEvent(event);\n        };\n        await send('start', 'retrieve');\n        await send('retrieve', 'grade_documents');\n        await send('grade_documents', 'transform_query');\n        await send('transform_query', 'retrieve');\n        await send('retrieve', 'grade_documents');\n        await send('grade_documents', 'generate');\n        await send('generate', 'generate');\n        await send('stop');\n        elem.dispatchEvent(new CustomEvent('state-updated', {\n            detail: 'stop',\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n    }\n};\nconst $fe8cbfd9ee8314da$export$b5b93dd066d67af9 = {\n    /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */ callInit: async (elem)=>{\n        /** @typedef {InitData} */ const detail = {\n            threads: [\n                [\n                    'default',\n                    []\n                ]\n            ],\n            title: 'LangGraph4j : TEST',\n            args: [\n                {\n                    name: 'input',\n                    type: 'IMAGE',\n                    required: true\n                }\n            ],\n            graph: `\n---\ntitle: Image to diagram with correction\n---\nflowchart TD\n\t__START__((start))\n\t__END__((stop))\n\tagent_describer(\"agent_describer\")\n\tagent_sequence_plantuml(\"agent_sequence_plantuml\")\n\tagent_generic_plantuml(\"agent_generic_plantuml\")\nsubgraph evaluate_result\n\t___START__((start)):::___START__\n\t___END__((stop)):::___END__\n\t_evaluate_result(\"evaluate_result\")\n\t_agent_review(\"agent_review\")\n\t%%\t_condition1{\"check state\"}\n\t___START__:::___START__ --> _evaluate_result:::_evaluate_result\n\t_agent_review:::_agent_review --> _evaluate_result:::_evaluate_result\n\t%%\t_evaluate_result:::_evaluate_result --> _condition1:::_condition1\n\t%%\t_condition1:::_condition1 -->|ERROR| _agent_review:::_agent_review\n\t_evaluate_result:::_evaluate_result -->|ERROR| _agent_review:::_agent_review\n\t%%\t_condition1:::_condition1 -->|UNKNOWN| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|UNKNOWN| ___END__:::___END__\n\t%%\t_condition1:::_condition1 -->|OK| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|OK| ___END__:::___END__\nend\n\t%%\tcondition1{\"check state\"}\n\t__START__:::__START__ --> agent_describer:::agent_describer\n\t%%\tagent_describer:::agent_describer --> condition1:::condition1\n\t%%\tcondition1:::condition1 -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\tagent_describer:::agent_describer -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\t%%\tcondition1:::condition1 -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_describer:::agent_describer -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_sequence_plantuml:::agent_sequence_plantuml --> evaluate_result:::evaluate_result\n\tagent_generic_plantuml:::agent_generic_plantuml --> evaluate_result:::evaluate_result\n\tevaluate_result:::evaluate_result --> __END__:::__END__\n\n\tclassDef ___START__ fill:black,stroke-width:1px,font-size:xx-small;\n\tclassDef ___END__ fill:black,stroke-width:1px,font-size:xx-small;\n  `\n        };\n        await $fe8cbfd9ee8314da$var$delay(1000);\n        /** @typedef {CustomEvent<InitData>} */ const event = new CustomEvent('init', {\n            detail: detail,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        });\n        elem.dispatchEvent(event);\n        // @ts-ignore\n        return detail;\n    },\n    /**\n  * @param   {HTMLElement}  elem\n  * @param   {string|undefined}  selectedThread \n  */ callSubmitAction: async (elem, selectedThread)=>{\n        const thread = selectedThread;\n        const send = async (/** @type {string} */ nodeId, /** @type {string} */ nextNodeId)=>{\n            /** @typedef {ResultData} */ const detail = [\n                thread,\n                {\n                    checkpoint: nodeId === 'start' || nodeId === 'stop' ? undefined : `checkpoint-${nodeId}`,\n                    node: nodeId,\n                    next: nextNodeId,\n                    state: {\n                        input: \"this is input\",\n                        property1: {\n                            value: \"value1\",\n                            valid: true\n                        },\n                        property2: {\n                            value: \"value2\",\n                            children: {\n                                elements: [\n                                    1,\n                                    2,\n                                    3\n                                ]\n                            }\n                        }\n                    }\n                }\n            ];\n            /** @typedef {CustomEvent<ResultData>} */ const event = new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            });\n            await $fe8cbfd9ee8314da$var$delay(1000);\n            elem.dispatchEvent(event);\n        };\n        await send('__START__', 'agent_describer');\n        await send('agent_describer', 'agent_sequence_plantuml');\n        await send('agent_generic_plantuml', '___START__');\n        await send('___START__', '_evaluate_result');\n        await send('_evaluate_result', '__END__');\n        await send('___END__');\n        await send('__END__');\n        elem.dispatchEvent(new CustomEvent('state-updated', {\n            detail: 'stop',\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n    }\n};\n\n\n\nvar $8uVid = parcelRequire(\"8uVid\");\n\"use strict\";\n\n\nconst $0ca21e1f1d158660$var$_DBG = (0, $8uVid.debug)({\n    on: true,\n    topic: 'LG4JExecutor'\n});\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData * \n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */ /**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */ const $0ca21e1f1d158660$var$delay = async (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * @async\n * @generator\n * @param {Response} response\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */ async function* $0ca21e1f1d158660$var$streamingResponse(response) {\n    // Attach Reader\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    while(reader){\n        // wait for next encoded chunk\n        const { done: done, value: value } = await reader.read();\n        // check if stream is done\n        if (done) break;\n        try {\n            buffer += decoder.decode(value);\n            const data = JSON.parse(buffer);\n            buffer = '';\n            yield data;\n        } catch (err) {\n            console.warn('JSON parse error:', err);\n        }\n    // Decodes data chunk and yields it\n    // yield (new TextDecoder().decode(value));\n    }\n}\nclass $0ca21e1f1d158660$export$2fe88ce002d9c04f extends (0, $800sp.LitElement) {\n    /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array<CSSResult>}\n   */ static styles = [\n        (0, $hNeh9.default),\n        (0, $800sp.css)`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n\n    .commands {\n      display: flex;\n      flex-direction: row;\n      column-gap: 10px;\n    }\n\n    .item1 {\n      flex-grow: 2;\n    }\n    .item2 {\n      flex-grow: 2;\n    }\n  `\n    ];\n    /**\n   * Properties of the component.\n   * \n   * @static\n   * @type { import('lit').PropertyDeclarations }\n   */ static properties = {\n        url: {\n            type: String,\n            reflect: true\n        },\n        test: {\n            type: Boolean,\n            reflect: true\n        },\n        _executing: {\n            state: true\n        }\n    };\n    /**\n   * @type {string | null }\n   */ url = null;\n    /**\n   * current selected thread\n   * \n   * @type {string|undefined} - thread id\n   */ #selectedThread;\n    /**\n   * current state for update \n   * \n   * @type {UpdatedState|null}\n   */ #updatedState = null;\n    /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */ constructor(){\n        super();\n        this.test = false;\n        /** @type {ArgumentMetadata[]} */ this.formMetaData = [];\n        this._executing = false;\n    }\n    #startExecution() {\n        this._executing = true;\n        this.dispatchEvent(new CustomEvent('state-updated', {\n            detail: 'start',\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n    }\n    /**\n   * \n   * @param {[ string, UpdatedState & { next: string } ]|Error|null} result \n   */ #stopExecution(result) {\n        this._executing = false;\n        // NO ACTION\n        if (!result) return;\n        // ON ERROR\n        if (result instanceof Error) {\n            this.dispatchEvent(new CustomEvent('state-updated', {\n                detail: 'error',\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n            return;\n        }\n        // ON SUCCESS\n        const [thread, { node: node }] = result;\n        // Asuume that flow is interrupted if last node is different by last node (__END__) \n        this.dispatchEvent(new CustomEvent('state-updated', {\n            detail: node !== '__END__' ? 'interrupted' : 'stop',\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n    }\n    /**\n   * Event handler for the 'update slected thread' event.\n   * \n   * @param {CustomEvent<string>} e - The event object containing the updated data.\n   */ #onThreadUpdated(e) {\n        $0ca21e1f1d158660$var$_DBG('thread-updated', e.detail);\n        this.#selectedThread = e.detail;\n        this.#updatedState = null;\n        this.requestUpdate();\n    }\n    /**\n   * \n   * @param {CustomEvent<UpdatedState>} e - The event object containing the result data.\n   */ #onNodeUpdated(e) {\n        $0ca21e1f1d158660$var$_DBG('onNodeUpdated', e);\n        this.#updatedState = e.detail;\n        this.requestUpdate();\n    }\n    /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */ connectedCallback() {\n        super.connectedCallback();\n        // @ts-ignore\n        this.addEventListener(\"thread-updated\", this.#onThreadUpdated);\n        // @ts-ignore\n        this.addEventListener('node-updated', this.#onNodeUpdated);\n        if (this.test) {\n            (0, $fe8cbfd9ee8314da$export$b5b93dd066d67af9).callInit(this).then((data)=>{\n                this.formMetaData = data.args;\n                this.requestUpdate();\n            });\n            return;\n        }\n        this.#callInit();\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        // @ts-ignore\n        this.removeEventListener(\"thread-updated\", this.#onThreadUpdated);\n        // @ts-ignore\n        this.removeEventListener('node-updated', this.#onNodeUpdated);\n    }\n    /**\n   * Renders the HTML template for the component.\n   * \n   * @returns The rendered HTML template.\n   */ render() {\n        return (0, $800sp.html)`\n        <div class=\"container\">\n          ${this.formMetaData.map(({ name: name, type: type })=>{\n            switch(type){\n                case 'STRING':\n                    return (0, $800sp.html)`<textarea id=\"${name}\" class=\"textarea textarea-primary\" placeholder=\"${name}\"></textarea>`;\n                case 'IMAGE':\n                    return (0, $800sp.html)`<lg4j-image-uploader id=\"${name}\"></lg4j-image-uploader>`;\n            }\n        })}\n          <div class=\"commands\">\n            <button id=\"submit\" ?disabled=${this._executing} @click=\"${this.#callSubmit}\" class=\"btn btn-primary item1\">Submit</button>\n            <button id=\"resume\" ?disabled=${!this.#updatedState || this._executing} @click=\"${this.#callResume}\" class=\"btn btn-secondary item2\">\n            Resume ${this.#updatedState ? '(from ' + this.#updatedState?.node + ')' : ''}\n            </button>\n          </div>\n        </div>\n        <!--\n        ==============\n        ERROR DIALOG \n        ==============\n        -->\n        <dialog id=\"error_dialog\" class=\"modal\">\n          <div class=\"modal-box\">\n            <form method=\"dialog\">\n              <button class=\"btn btn-sm btn-circle btn-ghost absolute right-2 top-2\">✕</button>\n            </form>\n              <div class=\"flex items-center gap-2 mb-4 text-error\">\n              <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              class=\"h-6 w-6 shrink-0 stroke-current\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\">\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n            </svg>\n            <p id=\"error_message\" class=\"text-lg font-bold\">ERROR</p>\n          </div>\n          </div>\n        </dialog>        \n        `;\n    }\n    /**\n   * \n   * @param {string} detail \n   */ #requestShowError(detail) {\n        const elem = this.shadowRoot?.getElementById('error_dialog');\n        if (elem && 'showModal' in elem) {\n            const msgElem = elem.querySelector('#error_message');\n            if (msgElem) msgElem.textContent = detail;\n            //@ts-ignore\n            elem.showModal();\n        // if( timeout ) {\n        //   await delay(timeout)\n        //   //@ts-ignore\n        //   elem.close()\n        // }\n        }\n    }\n    async #callInit() {\n        const initResponse = await fetch(`${this.url}/init`);\n        if (!initResponse.ok) {\n            this.#requestShowError(initResponse.statusText);\n            return null;\n        }\n        /** @type {InitData} */ const initData = await initResponse.json();\n        $0ca21e1f1d158660$var$_DBG('initData', initData);\n        this.dispatchEvent(new CustomEvent('init', {\n            detail: initData,\n            bubbles: true,\n            composed: true,\n            cancelable: true\n        }));\n        this.formMetaData = initData.args;\n        // this.#nodes = initData.nodes\n        this.requestUpdate();\n    }\n    async #callResume() {\n        this.#startExecution();\n        let result = null;\n        try {\n            if (this.test) {\n                await (0, $fe8cbfd9ee8314da$export$b5b93dd066d67af9).callSubmitAction(this, this.#selectedThread);\n                return;\n            }\n            result = await this.#callResumeAction();\n        } catch (err) {\n            if (err instanceof Error) {\n                this.#requestShowError(err.message);\n                result = err;\n            }\n        } finally{\n            this.#stopExecution(result);\n        }\n    }\n    async #callResumeAction() {\n        const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}&resume=true&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(this.#updatedState?.data)\n        });\n        if (!execResponse.ok) throw new Error(execResponse.statusText);\n        this.#updatedState = null;\n        /** @type [ string, UpdatedState & { next: string } ]|null */ let lastChunk = null;\n        for await (let detail of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            $0ca21e1f1d158660$var$_DBG(detail);\n            lastChunk = detail;\n            this.dispatchEvent(new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n        return lastChunk;\n    }\n    async #callSubmit() {\n        this.#startExecution();\n        let result = null;\n        try {\n            if (this.test) await (0, $fe8cbfd9ee8314da$export$b5b93dd066d67af9).callSubmitAction(this, this.#selectedThread);\n            result = await this.#callSubmitAction();\n        } catch (err) {\n            if (err instanceof Error) {\n                this.#requestShowError(err.message);\n                result = err;\n            }\n        } finally{\n            this.#stopExecution(result);\n        }\n    }\n    async #callSubmitAction() {\n        // Get input as object\n        /** @type { Record<string,any> } */ const result = {};\n        /** @type { Record<string,any> } data */ const data = this.formMetaData.reduce((acc, md)=>{\n            const { name: name, type: type } = md;\n            const elem = this.shadowRoot?.getElementById(name);\n            switch(type){\n                case 'STRING':\n                    //@ts-ignore\n                    acc[name] = elem?.value;\n                    break;\n                case 'IMAGE':\n                    //@ts-ignore\n                    acc[name] = elem?.value;\n                    break;\n            }\n            return acc;\n        }, result);\n        // const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}&resume=${interrupted}&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n        const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!execResponse.ok) throw new Error(execResponse.statusText);\n        /** @type [ string, UpdatedState & { next: string } ]|null */ let lastChunk = null;\n        for await (let detail of $0ca21e1f1d158660$var$streamingResponse(execResponse)){\n            $0ca21e1f1d158660$var$_DBG(\"SUBMIT RESULT\", detail);\n            // lastChunk = JSON.parse(chunk);\n            lastChunk = detail;\n            this.dispatchEvent(new CustomEvent('result', {\n                detail: detail,\n                bubbles: true,\n                composed: true,\n                cancelable: true\n            }));\n        }\n        return lastChunk;\n    }\n}\nwindow.customElements.define('lg4j-executor', $0ca21e1f1d158660$export$2fe88ce002d9c04f);\n\n\n//# sourceMappingURL=webui.ed791a41.js.map\n","\nimport TWStyles from './twlit.js';\n\nimport { html, css, LitElement, CSSResult } from 'lit';\n\nimport { imageToDiagram as test } from './lg4j-executor-test.js';\n\nimport { debug } from './debug.js';\nimport { exec } from 'child_process';\n\n\nconst _DBG = debug( { on: true, topic: 'LG4JExecutor' } )\n\n\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData * \n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */\n\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */\nconst delay = async (ms) => (new Promise(resolve => setTimeout(resolve, ms)));\n\n/**\n * Asynchronously fetches data from a given fetch call and yields the data in chunks.\n * @async\n * @generator\n * @param {Response} response\n * @yields {Promise<string>} The decoded text chunk from the response stream.\n */\nasync function* streamingResponse(response) {\n  // Attach Reader\n  const reader = response.body?.getReader();\n\n  const decoder = new TextDecoder();\n\n  let buffer = '';\n  while (true && reader) {\n    // wait for next encoded chunk\n    const { done, value } = await reader.read();\n    // check if stream is done\n    if (done) break;\n\n    try {\n      buffer += decoder.decode(value);\n      const data = JSON.parse(buffer);\n      buffer = '';\n      yield data;\n    } catch (err) {\n      console.warn('JSON parse error:', err );\n    }\n    // Decodes data chunk and yields it\n    // yield (new TextDecoder().decode(value));\n  }\n}\n\n/**\n * LG4JInputElement is a custom web component that extends LitElement.\n * It provides a styled input container with a placeholder.\n * \n * @class\n * @extends {LitElement}\n */\nexport class LG4JExecutorElement extends LitElement {\n\n  /**\n   * Styles applied to the component.\n   * \n   * @static\n   * @type {Array<CSSResult>}\n   */\n  static styles = [TWStyles, css`\n    .container {\n      display: flex;\n      flex-direction: column;\n      row-gap: 10px;\n    }\n\n    .commands {\n      display: flex;\n      flex-direction: row;\n      column-gap: 10px;\n    }\n\n    .item1 {\n      flex-grow: 2;\n    }\n    .item2 {\n      flex-grow: 2;\n    }\n  `];\n\n\n  /**\n   * Properties of the component.\n   * \n   * @static\n   * @type { import('lit').PropertyDeclarations }\n   */\n  static properties = {\n    url: { type: String, reflect: true },\n    test: { type: Boolean, reflect: true },\n    _executing: { state: true }\n\n  }\n\n  /**\n   * @type {string | null }\n   */\n  url = null\n\n  /**\n   * current selected thread\n   * \n   * @type {string|undefined} - thread id\n   */\n  #selectedThread\n\n  /**\n   * current state for update \n   * \n   * @type {UpdatedState|null}\n   */\n  #updatedState = null\n\n  /**\n   * Creates an instance of LG4JInputElement.\n   * \n   * @constructor\n   */\n  constructor() {\n    super();\n    this.test = false\n    /** @type {ArgumentMetadata[]} */\n    this.formMetaData = []\n    this._executing = false\n\n  }\n\n  #startExecution() {\n\n    this._executing = true\n    this.dispatchEvent(new CustomEvent('state-updated', {\n      detail: 'start',\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n  }\n\n  /**\n   * \n   * @param {[ string, UpdatedState & { next: string } ]|Error|null} result \n   */\n  #stopExecution( result ) {\n    this._executing = false\n    \n    // NO ACTION\n    if( !result ) {\n      return\n    }\n\n    // ON ERROR\n    if( result instanceof Error ) {\n      this.dispatchEvent(new CustomEvent('state-updated', {\n        detail: 'error',\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n      return \n    }\n    // ON SUCCESS\n    const [ thread, { node } ] = result\n    // Asuume that flow is interrupted if last node is different by last node (__END__) \n    this.dispatchEvent(new CustomEvent('state-updated', {\n        detail: ( node!=='__END__' ) ? 'interrupted' : 'stop',\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n  }\n  \n\n  /**\n   * Event handler for the 'update slected thread' event.\n   * \n   * @param {CustomEvent<string>} e - The event object containing the updated data.\n   */\n  #onThreadUpdated(e) {\n    _DBG('thread-updated', e.detail)\n    this.#selectedThread = e.detail\n    this.#updatedState = null\n    this.requestUpdate()\n  }\n\n  /**\n   * \n   * @param {CustomEvent<UpdatedState>} e - The event object containing the result data.\n   */\n  #onNodeUpdated(e) {\n    _DBG('onNodeUpdated', e)\n    this.#updatedState = e.detail\n    this.requestUpdate()\n  }\n\n  /**\n   * Lifecycle method called when the element is added to the document's DOM.\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    // @ts-ignore\n    this.addEventListener(\"thread-updated\", this.#onThreadUpdated);\n    // @ts-ignore\n    this.addEventListener('node-updated', this.#onNodeUpdated)\n\n    if (this.test) {\n      test.callInit(this)\n        .then(data => {\n          this.formMetaData = data.args \n          this.requestUpdate()\n        })\n      return\n    }\n\n    this.#callInit()\n\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    // @ts-ignore\n    this.removeEventListener(\"thread-updated\", this.#onThreadUpdated)\n    // @ts-ignore\n    this.removeEventListener('node-updated', this.#onNodeUpdated)\n  }\n\n  /**\n   * Renders the HTML template for the component.\n   * \n   * @returns The rendered HTML template.\n   */\n  render() {\n\n    return html`\n        <div class=\"container\">\n          ${this.formMetaData.map(({ name, type }) => {\n            switch (type) {\n              case 'STRING':\n                return html`<textarea id=\"${name}\" class=\"textarea textarea-primary\" placeholder=\"${name}\"></textarea>`\n              case 'IMAGE':\n                return html`<lg4j-image-uploader id=\"${name}\"></lg4j-image-uploader>`\n            }\n          })}\n          <div class=\"commands\">\n            <button id=\"submit\" ?disabled=${this._executing} @click=\"${this.#callSubmit}\" class=\"btn btn-primary item1\">Submit</button>\n            <button id=\"resume\" ?disabled=${!this.#updatedState || this._executing} @click=\"${this.#callResume}\" class=\"btn btn-secondary item2\">\n            Resume ${this.#updatedState ? '(from ' + this.#updatedState?.node + ')' : ''}\n            </button>\n          </div>\n        </div>\n        <!--\n        ==============\n        ERROR DIALOG \n        ==============\n        -->\n        <dialog id=\"error_dialog\" class=\"modal\">\n          <div class=\"modal-box\">\n            <form method=\"dialog\">\n              <button class=\"btn btn-sm btn-circle btn-ghost absolute right-2 top-2\">✕</button>\n            </form>\n              <div class=\"flex items-center gap-2 mb-4 text-error\">\n              <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              class=\"h-6 w-6 shrink-0 stroke-current\"\n              fill=\"none\"\n              viewBox=\"0 0 24 24\">\n              <path\n                stroke-linecap=\"round\"\n                stroke-linejoin=\"round\"\n                stroke-width=\"2\"\n                d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\" />\n            </svg>\n            <p id=\"error_message\" class=\"text-lg font-bold\">ERROR</p>\n          </div>\n          </div>\n        </dialog>        \n        `;\n  }\n\n  /**\n   * \n   * @param {string} detail \n   */\n  #requestShowError( detail ) {\n\n    const elem = this.shadowRoot?.getElementById('error_dialog')\n    if (elem && 'showModal' in elem ) {\n      const msgElem = elem.querySelector('#error_message')\n      if( msgElem ) {\n        msgElem.textContent = detail\n      }\n      //@ts-ignore\n      elem.showModal()\n      \n      // if( timeout ) {\n      //   await delay(timeout)\n      //   //@ts-ignore\n      //   elem.close()\n      // }\n   }\n  \n  }\n\n  async #callInit() {\n\n    const initResponse = await fetch(`${this.url}/init`)\n\n    if( !initResponse.ok ) {\n      this.#requestShowError(initResponse.statusText) \n      return null\n    }\n  \n    /** @type {InitData} */\n    const initData = await initResponse.json()\n\n    _DBG('initData', initData);\n\n    this.dispatchEvent(new CustomEvent('init', {\n      detail: initData,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n    this.formMetaData = initData.args\n    // this.#nodes = initData.nodes\n    this.requestUpdate()\n  }\n\n  async #callResume() {\n\n    this.#startExecution()\n    let result = null\n\n    try {\n\n      if (this.test) {\n        await test.callSubmitAction(this, this.#selectedThread);\n        return\n      }\n\n      result =  await this.#callResumeAction()\n\n    }\n    catch (err) {\n      if(err instanceof Error) {\n        this.#requestShowError(err.message)\n        result = err\n      }\n    }\n    finally {\n      this.#stopExecution(result)\n    }\n\n  }\n\n  async #callResumeAction() {\n\n    const execResponse = await fetch(`${ this.url}/stream?thread=${this.#selectedThread}&resume=true&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n      method: 'POST', // *GET, POST, PUT, DELETE, etc.\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify( this.#updatedState?.data )\n    });\n\n    if( !execResponse.ok ) {\n      throw new Error( execResponse.statusText )\n    }\n\n    this.#updatedState = null\n\n    /** @type [ string, UpdatedState & { next: string } ]|null */\n    let lastChunk = null\n\n    for await (let detail of streamingResponse(execResponse)) {\n      _DBG( detail)\n      \n      lastChunk = detail\n\n      this.dispatchEvent(new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n    }\n\n    return lastChunk\n\n  }\n\n  async #callSubmit() {\n\n    this.#startExecution()\n    let result = null\n\n    try {\n\n      if (this.test) {\n        await test.callSubmitAction(this, this.#selectedThread);\n        // await delay(1000);\n        // throw new Error('Error test')\n      }\n\n      result = await this.#callSubmitAction()\n    }\n    catch (err) {\n      if(err instanceof Error) {\n        this.#requestShowError(err.message)\n        result = err\n      }\n    }\n    finally {\n        this.#stopExecution(result)\n\n    }\n  }\n\n  async #callSubmitAction() {\n\n    // Get input as object\n    /** @type { Record<string,any> } */\n    const result = {}\n    /** @type { Record<string,any> } data */\n    const data = this.formMetaData.reduce((acc, md) => {\n\n      const { name, type } = md\n      const elem = this.shadowRoot?.getElementById(name)\n\n      switch (type) {\n        case 'STRING':\n          //@ts-ignore\n          acc[name] = elem?.value\n          break;\n        case 'IMAGE':\n          //@ts-ignore\n          acc[name] = elem?.value\n          break;\n      }\n\n      return acc\n    }, result);\n\n    \n    // const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}&resume=${interrupted}&node=${this.#updatedState?.node}&checkpoint=${this.#updatedState?.checkpoint}`, {\n    const execResponse = await fetch(`${this.url}/stream?thread=${this.#selectedThread}`, {\n        method: 'POST', // *GET, POST, PUT, DELETE, etc.\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n  \n    if( !execResponse.ok ) {\n      throw new Error( execResponse.statusText )\n    }\n\n    /** @type [ string, UpdatedState & { next: string } ]|null */\n    let lastChunk = null\n    \n    for await (let detail of streamingResponse(execResponse)) {\n      _DBG( \"SUBMIT RESULT\", detail)\n\n      // lastChunk = JSON.parse(chunk);\n      lastChunk = detail\n\n      this.dispatchEvent(new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      }));\n\n    }\n    \n    return lastChunk\n\n  }\n\n}\nwindow.customElements.define('lg4j-executor', LG4JExecutorElement);\n","\n/**\n * @file\n * @typedef {import('./types.js').ResultData} ResultData\n * @typedef {import('./types.js').EditEvent} EditEvent\n * @typedef {import('./types.js').UpdatedState} UpdatedState\n * @typedef {import('./types.js').InitData} InitData\n * @typedef {import('./types.js').ArgumentMetadata} ArgumentMetadata\n * \n */\n\n/**\n * Asynchronously waits for a specified number of milliseconds.\n * \n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} A promise that resolves after the specified delay.\n */\nconst delay = async (ms) => (new Promise(resolve => setTimeout(resolve, ms)));\n\nexport const adaptiveRAG = {\n  /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */\n  callInit: async (elem) => {\n\n    /** @typedef {InitData} */\n    const detail = {\n      threads: [['default', []]],\n      title: 'LangGraph4j : TEST',\n      args: [\n        { name: 'input', type: 'STRING', required: true }\n      ],\n      graph: `\n---\ntitle: TEST\n---        \nflowchart TD\n  start((start))\n  stop((stop))\n  web_search(\"web_search\")\n  retrieve(\"retrieve\")\n  grade_documents(\"grade_documents\")\n  generate(\"generate\")\n  transform_query(\"transform_query\")\n  start:::start -->|web_search| web_search:::web_search\n  start:::start -->|vectorstore| retrieve:::retrieve\n  web_search:::web_search --> generate:::generate\n  retrieve:::retrieve --> grade_documents:::grade_documents\n  grade_documents:::grade_documents -->|transform_query| transform_query:::transform_query\n  grade_documents:::grade_documents -->|generate| generate:::generate\n  transform_query:::transform_query --> retrieve:::retrieve\n  generate:::generate -->|not supported| generate:::generate\n  generate:::generate -->|not useful| transform_query:::transform_query\n  generate:::generate -->|useful| stop:::stop\n      `\n    }\n\n    await delay(1000);\n\n    /** @typedef {CustomEvent<InitData>} */\n    const event = new CustomEvent('init', {\n      detail,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    });\n\n\n    elem.dispatchEvent(event);\n\n    // @ts-ignore\n    return detail;\n  },\n\n\n  /**\n   * @param   {HTMLElement}  elem\n   * @param   {string|undefined}  selectedThread \n   */\n  callSubmitAction: async (elem, selectedThread) => {\n\n    const thread = selectedThread\n\n    const send = async ( /** @type {string} */ nodeId, /** @type {string} */ nextNodeId) => {\n\n      /** @typedef {ResultData} */\n      const detail = [thread, {\n        checkpoint: (nodeId === 'start' || nodeId === 'stop') ? undefined : `checkpoint-${nodeId}`,\n        node: nodeId,\n        next: nextNodeId,\n        state: {\n          input: \"this is input\",\n          property1: { value: \"value1\", valid: true },\n          property2: { value: \"value2\", children: { elements: [1, 2, 3] } }\n        }\n      }\n      ]\n\n      /** @typedef {CustomEvent<ResultData>} */\n      const event = new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      });\n\n      await delay(1000);\n      elem.dispatchEvent(event);\n    }\n\n    await send('start', 'retrieve');\n    await send('retrieve', 'grade_documents');\n    await send('grade_documents', 'transform_query');\n    await send('transform_query', 'retrieve');\n    await send('retrieve', 'grade_documents');\n    await send('grade_documents', 'generate');\n    await send('generate', 'generate');\n    await send('stop');\n\n    elem.dispatchEvent(new CustomEvent('state-updated', {\n      detail:  'stop',\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n  }\n\n};\n\nexport const imageToDiagram = {\n  /**\n   * @param   {HTMLElement}  elem  \n   * @returns {Promise<InitData>}\n   */\n  callInit: async (elem) => {\n\n    /** @typedef {InitData} */\n    const detail = {\n      threads: [['default', []]],\n      title: 'LangGraph4j : TEST',\n      args: [\n        { name: 'input', type: 'IMAGE', required: true }\n      ],\n      graph: `\n---\ntitle: Image to diagram with correction\n---\nflowchart TD\n\t__START__((start))\n\t__END__((stop))\n\tagent_describer(\"agent_describer\")\n\tagent_sequence_plantuml(\"agent_sequence_plantuml\")\n\tagent_generic_plantuml(\"agent_generic_plantuml\")\nsubgraph evaluate_result\n\t___START__((start)):::___START__\n\t___END__((stop)):::___END__\n\t_evaluate_result(\"evaluate_result\")\n\t_agent_review(\"agent_review\")\n\t%%\t_condition1{\"check state\"}\n\t___START__:::___START__ --> _evaluate_result:::_evaluate_result\n\t_agent_review:::_agent_review --> _evaluate_result:::_evaluate_result\n\t%%\t_evaluate_result:::_evaluate_result --> _condition1:::_condition1\n\t%%\t_condition1:::_condition1 -->|ERROR| _agent_review:::_agent_review\n\t_evaluate_result:::_evaluate_result -->|ERROR| _agent_review:::_agent_review\n\t%%\t_condition1:::_condition1 -->|UNKNOWN| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|UNKNOWN| ___END__:::___END__\n\t%%\t_condition1:::_condition1 -->|OK| ___END__:::___END__\n\t_evaluate_result:::_evaluate_result -->|OK| ___END__:::___END__\nend\n\t%%\tcondition1{\"check state\"}\n\t__START__:::__START__ --> agent_describer:::agent_describer\n\t%%\tagent_describer:::agent_describer --> condition1:::condition1\n\t%%\tcondition1:::condition1 -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\tagent_describer:::agent_describer -->|sequence| agent_sequence_plantuml:::agent_sequence_plantuml\n\t%%\tcondition1:::condition1 -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_describer:::agent_describer -->|generic| agent_generic_plantuml:::agent_generic_plantuml\n\tagent_sequence_plantuml:::agent_sequence_plantuml --> evaluate_result:::evaluate_result\n\tagent_generic_plantuml:::agent_generic_plantuml --> evaluate_result:::evaluate_result\n\tevaluate_result:::evaluate_result --> __END__:::__END__\n\n\tclassDef ___START__ fill:black,stroke-width:1px,font-size:xx-small;\n\tclassDef ___END__ fill:black,stroke-width:1px,font-size:xx-small;\n  `\n    }\n\n    await delay(1000);\n\n    /** @typedef {CustomEvent<InitData>} */\n    const event = new CustomEvent('init', {\n      detail,\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    });\n\n    elem.dispatchEvent(event);\n\n    // @ts-ignore\n    return detail\n  },\n\n\n  /**\n  * @param   {HTMLElement}  elem\n  * @param   {string|undefined}  selectedThread \n  */\n  callSubmitAction: async (elem, selectedThread) => {\n\n    const thread = selectedThread\n\n    const send = async ( /** @type {string} */ nodeId, /** @type {string} */ nextNodeId) => {\n\n      /** @typedef {ResultData} */\n      const detail = [thread, {\n        checkpoint: (nodeId === 'start' || nodeId === 'stop') ? undefined : `checkpoint-${nodeId}`,\n        node: nodeId,\n        next: nextNodeId,\n        state: {\n          input: \"this is input\",\n          property1: { value: \"value1\", valid: true },\n          property2: { value: \"value2\", children: { elements: [1, 2, 3] } }\n        }\n      }]\n\n      /** @typedef {CustomEvent<ResultData>} */\n      const event = new CustomEvent('result', {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      });\n\n      await delay(1000);\n      elem.dispatchEvent(event);\n    }\n\n    await send('__START__', 'agent_describer');\n    await send('agent_describer', 'agent_sequence_plantuml');\n    await send('agent_generic_plantuml', '___START__');\n    await send('___START__', '_evaluate_result');\n    await send('_evaluate_result', '__END__');\n    await send('___END__');\n    await send('__END__');\n\n    elem.dispatchEvent(new CustomEvent('state-updated', {\n      detail:  'stop',\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    }));\n\n  }\n\n}","\"use strict\";"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$hNeh9","$800sp","$fe8cbfd9ee8314da$var$delay","ms","Promise","resolve","setTimeout","$fe8cbfd9ee8314da$export$b5b93dd066d67af9","callInit","elem","detail","threads","title","args","name","type","required","graph","event","CustomEvent","bubbles","composed","cancelable","dispatchEvent","callSubmitAction","selectedThread","send","nodeId","nextNodeId","checkpoint","undefined","node","next","state","input","property1","value","valid","property2","children","elements","$0ca21e1f1d158660$var$_DBG","$8uVid","debug","on","topic","$0ca21e1f1d158660$var$streamingResponse","response","reader","body","getReader","decoder","TextDecoder","buffer","done","read","decode","data","JSON","parse","console","warn","$0ca21e1f1d158660$export$2fe88ce002d9c04f","LitElement","styles","default","css","properties","url","String","reflect","test","Boolean","_executing","constructor","formMetaData","result","thread","e","requestUpdate","connectedCallback","addEventListener","then","disconnectedCallback","removeEventListener","render","html","map","shadowRoot","getElementById","msgElem","querySelector","textContent","showModal","initResponse","fetch","ok","statusText","initData","json","message","execResponse","method","headers","stringify","lastChunk","reduce","acc","md","window","customElements","define"],"version":3,"file":"webui.ed791a41.js.map"}